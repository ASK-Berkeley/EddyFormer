from nsm.typing import *
from nsm import field_utils

from nsm.flow import Flow
from nsm.solver.pseudo_spectral import PseudoSpectral, Forcing

class TurbulenceState(nn.Module):

  """
    Turbulence at equilibrium state.
  """

  t0: float
  scale: float
  wavenumber: int
  resolution: Shape

  t: float
  solver: PseudoSpectral

  def init_state(self, prng: Array) -> Grid:

    ndim = len(self.resolution)
    ks = field_utils.wavenumber(*(self.wavenumber, ) * ndim, complex=False)
    std = (sum(map(jnp.abs, ks)) ** (-5 / 3)).at[(0, ) * ndim].set(0)

    def sample(prng: Array) -> Array:

      x_ = jrand.normal(prng, std.shape) * std
      x_, = field_utils.interp([x_], self.resolution, fourier=True)

      x = jnp.fft.irfftn(x_, x_.shape, norm="forward")
      return x / jnp.max(jnp.abs(x)) * self.scale

    rngs = jrand.split(prng, ndim)
    vel = list(jax.vmap(sample)(rngs))

    if self.solver.form == "velocity": state = vel
    if self.solver.form == "vorticity":
      state = field_utils.vel2vor(vel)

    if self.t0:
      logging.info(f"Burning in for {self.t0}s ...")
      state = self.solver(state, jnp.array(self.t0))

    return state

  @nn.compact
  def __call__(self, batch_size: int) -> Grid:
    """
      Sample a batch of initial veloticities and perform a burning-
      in. Turbulence states are generated by running the solver for
      a fixed number of time steps.
    """
    prng = self.make_rng("sample")
    rngs = jrand.split(prng, batch_size)

    state = self.variable("state", "u", jax.vmap(self.init_state), rngs)
    state.value = jax.vmap(F.partial(self.solver, ts=jnp.array(self.t)))(state.value)

    size = 2 * jnp.pi * jnp.ones(len(self.resolution))
    return jax.vmap(F.partial(field_utils.to_grid, size=size))(state.value)

class Homegeneous(Flow):

  """
    Homogeneous turbulence.
  """

  forcing: Forcing
  ic: TurbulenceState

  form: str     # velocity or vorticity
  nu: float     # kinetic viscosity
  s: int        # domain size factor

  solver_res: Shape
  correction: float

  def __init__(self, base_dir: str, form: str, nu: float, s: int, t: float,
               initial_condition: ConfigDict, solver: ConfigDict, solver_res: Shape, correction: float):

    self.base_dir = base_dir
    self.form = form

    self.nu = nu
    self.s = s
    self.t = t

    self.solver = PseudoSpectral(solver, self.forcing, self.form, self.nu, self.s)
    self.ic = TurbulenceState(**initial_condition, solver=self.solver, t=t)

    self.solver_res = solver_res
    self.correction = correction

  @property
  def L(self) -> float:
    return 2 * jnp.pi * self.s

# ----------------------------------- FLOW ----------------------------------- #

  def solve(self, ic: Grid, ts: Maybe[Array] = None, aux_data: PyTree = None) -> Grid:
    """
      Run pseudo-spectral solver.
    """
    if ts is None:
      ts = self.t

    us = field_utils.interp(field_utils.from_grid(ic), self.solver_res)
    return field_utils.to_grid(self.solver(us, ts, aux_data), ic.size, isinstance(ts, Array) and ts.ndim)

  def process(self, ic: Grid, out: DataType, aux_data: PyTree) -> Tuple[DataType, Maybe[Grid]]:
    """
      Append the velocity field or solver guess to the initial condition.
    """
    u0, value = None, ic.value

    if self.correction:
      u0 = self.solve(ic, aux_data=aux_data)
      value = u0.interp(ic, "pbc").value
    if self.form == "vorticity":
      vel = field_utils.to_grid(field_utils.vor2vel(field_utils.from_grid(ic)), ic.size)
      value = jnp.concatenate([value, vel.value], axis=-1)
    return Grid(value, ic.size).interp(out, "pbc"), u0

  def project(self, u: DataType, u0: Maybe[DataType], out: Maybe[Grid]) -> DataType:
    """
      Correct the solver with prediction.
    """
    if isinstance(u, SEM):
      u = u.eval(out.resolution)

    if u0 is None: return u
    u0 = u0.interp(out, "pbc")

    return Grid(u0.value + u.value * self.correction, u0.size)

  def metric(self, u: Grid, ut: Grid) -> PyTree:
    """
      Metrics for the Navier-Stokes equation:
        - Pearson correlation factor,
        - relative l2 / mean absolute error.
    """
    u = jnp.moveaxis(u.value, -1, 0)
    ut = jnp.moveaxis(ut.value, -1, 0)

    def named(metrics: List[Array]) -> Dict[str, Array]:
      if len(metrics) == 1: var = ["z"] # 2D vorticity form
      if len(metrics) == 2: var = ["x", "y"] # 2D velocity form
      if len(metrics) == 3: var = ["x", "y", "z"] # 3D general form
      return { var[i]: metric for i, metric in enumerate(metrics) }

    return {
      "corr": named(list(map(utils.corr, u, ut))),
      "rel_err": named(list(map(utils.err, u, ut))),
      "abs_err": named(list(map(utils.mae, u, ut))),
    }

  def loss_data(self, u: Grid, ut: Grid) -> Array:
    return utils.err(u.value, ut.value) # rel. err

# ---------------------------------- DATASET --------------------------------- #

  @F.lru_cache
  def dataset_files(self, split: str) -> List[str]:
    logging.info(f"Loading {split} dataset under {self.base_dir} ...")
    return [f"{self.base_dir}/{fname}" for fname in sorted(os.listdir(self.base_dir))
      if fname.startswith(split + ".") and fname.endswith(".npy")]

  def dataset_transform(self, fname: str, window: Maybe[int], prng: Maybe[Array]) -> Flow.Data:
    """
      Sub-sample the dataset with given temporal resolution
      and apply transformation. Each trajectory is a `.npy`
      file with the following key-value pairs:

        - `u`: Solution trajectory.
        - `dt`: Temporal resolution.
    """
    data = jnp.load(fname, allow_pickle=True).item()

    u, t0 = data["u"], 0.
    if window is not None:
      l = window * int(self.t / data["dt"])
      s = jrand.choice(prng, len(u) - l).item()
      u, t0 = u[s:s + l + 1], s * data["dt"]

    u = u[::(k:=int(self.t / (dt:=data["dt"])))]
    assert math.isclose(self.t, dt * k)

    return [Flow.Data_t(
      t0 + n * self.t,
      Grid(jnp.array(ic), jnp.array([self.L] * self.ndim)),
      Grid(jnp.array(ut), jnp.array([self.L] * self.ndim)),
    ) for n, (ic, ut) in enumerate(zip(u[:-1], u[1:]))]

# ---------------------------------------------------------------------------- #
#                                KOLMOGOROV FLOW                               #
# ---------------------------------------------------------------------------- #

class KolmogorovFlow(Homegeneous):

  """
    Kolmogorov flow with forcing and damping terms. The forcing
    term injects energy at a specific mode, and the damping term
    prevents the energy accumulation at the lowest modes.

    The forcing is given by,
      f = ey sin(mode*x) - alpha v
  """

  mode: int     # forcing mode
  alpha: float  # damping term

  def __init__(self, base_dir: str, mode: int, alpha: float, s: int, **kwargs):
    default_dir = f"data/ns2d-kf{mode}s{s}" if s > 1 else f"data/ns2d-kf{mode}"
    super().__init__(base_dir or default_dir, "vorticity", s=s, **kwargs)

    self.ndim = 2
    self.odim = 1

    self.mode = mode
    self.alpha = alpha

  def forcing(self, ws_: field_utils.Field) -> field_utils.Field:
    """
      Sinusoidal forcing with damping.
    """
    f_ = [-u_ * self.alpha for u_ in ws_]
    k = self.mode * self.s # forcing mode

    f_[2] = f_[2].at[k, 0].add(self.mode/2)
    f_[2] = f_[2].at[-k, 0].add(self.mode/2)

    return f_

# ---------------------------------------------------------------------------- #
#                             ISOTROPIC TURBULENCE                             #
# ---------------------------------------------------------------------------- #

class Isotropic(Homegeneous):

  """
    Homegeneous isotropic turbulence maintained by applying a
    constant power input at lowest velocity modes.

    The forcing is given by,
      f = P_in \frac {\sum_{|k| <= mode} u_k e^{ikx}}
                     {\sum_{|k| <= mode} u_k ** 2}
  """

  mode: int     # forcing mode
  P_in: float   # input power

  def __init__(self, base_dir: str, name: str, mode: int, P_in: float, **kwargs):
    super().__init__(base_dir or f"data/ns3d-{name}", "velocity", s=1, **kwargs)

    self.ndim = 3
    self.odim = 3

    self.mode = mode
    self.P_in = P_in

  def forcing(self, vs_: field_utils.Field) -> field_utils.Field:
    """
      Isotropic forcing on lowest modes.
    """
    ks = field_utils.wavenumber(*field_utils.shape(vs_), complex=False)
    mask = F.reduce(jnp.logical_and, (jnp.abs(k) <= self.mode for k in ks))

    vs_k = [jnp.where(mask, v_, 0j) for v_ in vs_]
    Ek = sum(jnp.sum(v_k * v_k.conj()) for v_k in vs_k)

    return [v_k * self.P_in / (Ek * 2) for v_k in vs_k]
